# Java内存模型

>JVM在执行Java程序的时候会把它所管理的内存分为若干个不同的数据区域。每个区域都有各自的用途，下图是JVM所管理的内存划分的区域：



## 程序计数器

程序计数器是一块较小的内存空间，是线程私有的，可以看做是当前线程所执行的字节码的行号指示器

## Java虚拟机栈

Java虚拟机栈是线程私有的，生命周期与线程相同。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
- **局部变量表**：存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型
- **操作栈**：操作栈元素的数据类型必须与字节码指令序列严格匹配
- **动态连接**：指向运行时常量池中该栈帧所属方法的引用
- **方法返回地址**
    - 正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者
    - 异常退出，遇到Exception，并且方法没有捕获异常，那么不会有任何返回值


## 本地方法栈

本地方法栈为jvm使用到的native方法提供内存空间，而虚拟机栈为java方法提供内存空间，有些虚拟机将本地方法栈和虚拟机栈合二为一

## Java堆

Java堆是Java虚拟机所管理的内存中最大的一块，Java堆是线程共享的一块内存区域，虚拟机启动时创建。几乎所有的对象实例以及数组都是在堆上分配。

## 方法区

方法区主要存放的是已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。GC在该区域出现的比较少

## 运行时常量池

运行时常量池用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
- **字面量**：文本字符串等
- **符号引用**：编译语言层面的概念，包括以下3类：
    - 类和接口的全限定名
    - 字段的名称和描述符
    - 方法的名称和描述符

**符号引用的理解：在编译时，Java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如com.cqupt.project.W类引用了org.cqupt.D类，在编译时W类并不知道D类的实际内存地址，因此只能使用符号xxx来表示D类的地址。在装载器装载D类的实际内存地址时，此时可以获取到D类的实际地址，因此可以将符号替换为D类的实际内存地址**

## 关于常量池的一个小例子

```Java
String s1 = "hello";
String s2 = "hello";
String s3 = "hel" + "lo";
String s4 = "hel" + new String("lo");
String s5 = new String("hello");
String s6 = s5.intern();
String s7 = "h";
String s8 = "ello";
String s9 = s7 + s8;

System.out.println(s1 == s2);  // true
System.out.println(s1 == s3);  // true
System.out.println(s1 == s4);  // false
System.out.println(s1 == s9);  // false
System.out.println(s4 == s5);  // false
System.out.println(s1 == s6);  // true
```

s1==s2，这个很好理解，两个变量在赋值时，都是使用的字符串字面量。在编译时，这种字面量会直接放在class文件的常量池中，从而实现复用。

s1==s3，虽然s3是拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量。在编译时，这种拼接会被优化，编译器直接帮你拼接好，所以在class文件中，s3被优化成String s3 = "hello"

s1==s4，s4虽然是拼接出来的，但是new String("lo")这部分不是已知字面量，是一个不可预测部分，编译期不会优化，必须等到运行时才可以确定。

![](https://github.com/weiguangshuai/note/blob/master/%E5%9B%BE%E5%BA%8A/jvm1.png)

 s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，所以不做优化，等到运行时，s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同

 ![](https://github.com/weiguangshuai/note/blob/master/%E5%9B%BE%E5%BA%8A/jvm2.png)

  s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等