# 树及其应用

> 由n个节点组成的有限集合，树的定义是递归的，因为树的定义中又用到了树的定义。它刻画了树的固有特性，即一棵树由若干颗不相互的子树构成

**树的常用术语**：

- **度**：树中某个节点的子树个数称为该`节点的度`。树中各个节点度的最大值称为`树的度`。

- **分支节点和叶子节点**：度不为零的节点称为非终端节点，又叫`分支节点`。度为零的节点称为终端节点或者是`叶子节点`。

- **孩子节点、双亲节点和兄弟节点**：一棵树中，每个节点的后继结点称为该节点的`孩子节点`，该节点被称为其孩子节点的`双亲节点`，具有同一双亲节点的互为`兄弟节点`。

- **有序树和无序树**:树中各节点的子树是按照一定的次序从左到右安排的，且相对次序是不能随意变换的，则称为`有序树`，否则称为`无序树`。

**树的性质**：

- 树中的节点数等于所有节点的度加1

- 度为m的树中第i层上至多有`M^i-1`个节点

- 高度为h的m次树至多有`m^h-1/m-1`个节点

## 树的存储结构

1、**双亲存储结构**：这种存储结构是一种顺序存储结构，用一组连续空间存储树的所有节点，同时在每个节点上设置一个指针指示其双亲节点的位置。

C语言描述

```C

typedef struct {
    ElemType data;
    int parent;
} PTree[MaxSize]

```

Java描述

```Java
//默认情况下可以设定根节点的parent为空
public class TreeNode{
    int data;
    TreeNode parent;
}

```

2、**孩子链存储结构**：这种存储方式，每个节点不仅保存了节点的数值，而且还保存了指向其所有孩子节点的指针。

C语言描述

```C
typedef struct node {
    ElemType data;
    struct node * sons[Maxsons];
} TSonNode

```

Java描述

```Java
public class TreeNode {
    int data;
    List sons = new ArrayList<>();//利用java中比较的集合可以很方便的来实现动态存储孩子节点值
}

```

3、**孩子兄弟链存储结构**:孩子兄弟链存储结构是为了每个节点设计了3个域：一个数据元素域，一个指向该节点的第一个孩子节点的指针域，一个指向了该节点的下一个兄弟节点的指针域。

C语言描述

```C

typedef struct tnode {
    ElemType data;
    struct tnode *hp;
    struct tnode *vp;
}TSBNode;

```

Java描述

```Java

public class TreeNode {
    int data;
    TreeNode son;
    TreeNode brother;
}

```


## 二叉树
>每个节点的度最多为二的树结构

**二叉树的性质**：

- 非空二叉树上叶子节点数等于双分支节点数加1

- 非空二叉树上第i层上至多有`2^(i-1)`个节点

- 高度为h的二叉树至多有`2^h - 1`个节点


**二叉树与树、森林之间的转化**

**树转化为二叉树**：

1、在所有相邻兄弟节点（森林中每棵树的根节点可以看成是兄弟节点）之间加一条水平连线

2、对每个非叶子节点k，除了其最左边的孩子节点外，删去k与其他孩子节点的连线

3、所有的水平线段以左边为节点为轴心顺时针旋转45°


**二叉树还原树**：

1、对于一颗二叉树中任一个节点k1，沿着k1右孩子节点的右子树方向搜索所有右孩子节点，即搜索节点序列k2，k3，...,其中k2是k1的右孩子节点

2、删去k1,k2,k3之间的连线

3、若k1有双亲节点k，则连接k与其他孩子节点

4、将图形规整化，使各个节点按层次排列


**二叉树的存储结构**

- 顺序存储结构：顺序存储结构就是用一组数组来存放二叉树的数据元素，由于数组的下标是从0开始的，而树的根节点一般从1开始，所有存放树的数组下标为0的位置不存放，对于节点也用其他的符号去代替

- 链式存储结构：一个链表来存储一颗二叉树，二叉树中每一个节点用链表中的一个链节点来存储

**二叉树的遍历**

1、递归遍历算法，三种遍历方法的递归算法实现

```Java
public class Main {
    //先序遍历
    public void preOrder(TreeNode node) {
        if(node != null) {
            //打印根节点
            System.out.println(node.data);
            //遍历左子树
            preOrder(node.left);
            //遍历右子树
            preOrder(node.right);
        }
    }

    //中序遍历
    public void inOrder(TreeNode node) {
        if(node != null) {
            //遍历左子树
            inOrder(node.left);
            //访问根节点
            System.out.println(node.data);
            //遍历右子树
            inOrder(node.right);
        }
    }

    //后序遍历
    public void postOrder(TreeNode node) {
        if(node != null) {
            //遍历左子树
            postOrder(node.left);
            //遍历右子树
            postOrder(node.right);
            //访问根节点
            System.out.println(node.data);
        }
    }
}

```

2、非递归算法遍历二叉树
- 先序遍历思路：先将根节点进栈，在栈不为空时循环：出栈p，访问p节点，若其右孩子节点不空将右孩子节点进栈，若其左孩子节点不为空再将其左孩子节点进栈
```Java
public class Main{
    //先序遍历非递归方法
    public void preOrder(TreeNode node) {

    }
}

```





